{"title":"Manejo de datos: importación, selección y revisión","markdown":{"headingText":"Manejo de datos: importación, selección y revisión","containsRefs":false,"markdown":"\n## Previo\n\n```{r echo=F}\n#setwd(\"C:/Users/anaes/Dropbox/2021/CursoR-posgrado\")# Cambio de directorio\n```\n\nVamos a llamar algunas librerías básicas, el tidyverse (que son muchas librerías) y sjlabelled que nos sirve para el manejo de etiquetas\n\n```{r}\nif (!require(\"pacman\")) install.packages(\"pacman\") # instala pacman si se requiere\npacman::p_load(tidyverse, haven, sjlabelled, foreign, janitor) #carga los paquetes necesarios para esta práctica\n```\n\n## Importación de datos\n\n### Desde Excel\n\nEl paquete más compatible con RStudio es readxl. A veces, otros paquetes tienen más problemas de configuración entre R y el Java.\n\n```{r 3}\nejemploxl <- readxl::read_excel(\"datos/ejemplo_xlsx.xlsx\", sheet = \"para_importar\")\n\n```\n\nComo el nombre de paquete lo indica, sólo lee. Para escribir en este formato, recomiendo el paquete \"writexl\". Lo instalamos anteriormente.\n\nSi quisiéramos exportar un objeto a Excel\n\n```{r 5}\nwritexl::write_xlsx(ejemploxl, path = \"Mi_Exportación.xlsx\")\n```\n\n### Desde STATA y SPSS\n\nSi bien también se puede realizar desde el paquete foreign. Pero este no importa algunas características como las etiquetas y tampoco funciona con las versiones más nuevas de STATA. Vamos a instalar otro paquete, compatible con el mundo tidyverse.\n\nRecuerda que no hay que instalarlo (viene adentro de tidyverse). Se instalasólo la primera vez. Una vez instalado un paquete, lo llamamos con el comando \"library\"\n\n```{r}\nconcentrado2020 <- haven::read_dta(\"datos/concentrado2020.dta\")\n```\n\n!Importante, a R no le gustan los objetos con nombres que empiezan en números\n\nEl paquete haven sí exporta información.\n\n```{r}\nhaven::write_dta(concentrado2020, \"datos/mi_exportación.dta\", version = 12)\n```\n\nCon SSPS es muy parecido. Dentro de \"haven\" hay una función específica para ello.\n\n```{r}\n#encevi_hogar<- haven::read_sav(\"datos/encevi_hogar.sav\")\n\n```\n\nPara escribir\n\n```{r}\n#haven::write_sav(concentrado2020 , \"mi_exportacion.sav\")\n```\n\nCheca que en todas las exportaciones en los nombres hay que incluir la extensión del programa. Si quieres guardar en un lugar diferente al directorio del trabajo, hay que escribir toda la ruta dentro de la computadora.\n\n## Revisión de nuestra base\n\nVamos a revisar la base, brevemente la base\n\n```{r}\nclass(concentrado2020) # tipo de objeto\nnames(concentrado2020) # lista las variables\nhead(concentrado2020) # muestra las primeras 6 líneas\ntable(concentrado2020$clase_hog) # un tabulado simple\n```\n\n## Revisión con dplyr\n\nOperador de \"pipe\" o \"tubería\" %\\>% (Ctrl+Shift+M) Antes de continuar, presentemos el operador \"pipe\" %\\>%. dplyr importa este operador de otro paquete (magrittr). Este operador le permite canalizar la salida de una función a la entrada de otra función. En lugar de funciones de anidamiento (lectura desde adentro hacia afuera), la idea de la tubería es leer las funciones de izquierda a derecha.\n\n```{r}\nconcentrado2020 %>% \n    dplyr::select(sexo_jefe, edad_jefe) %>% \n    head\n```\n\n```{r}\nconcentrado2020 %>% \n    dplyr::select(sexo_jefe, edad_jefe) %>% \n    glimpse\n```\n\n## Etiquetas y cómo usarlas\n\nPodemos ver que los objetos \"data.frame\"(*spoiler*, ya hablaremos de ellos)\n\n```{r}\n\nclass(concentrado2020$sexo_jefe)\n\n```\n\n### Ejemplo de etiquetado\n\nPara que se vea mejor nuestro tabulado, sería bueno que nuestras variables tuvieran etiqueta. Para ello utilizaremos el paquete \"sjlabelled\"\n\n```{r}\netiqueta_sex<-c(\"Hombre\", \"Mujer\")\n\nconcentrado2020<-concentrado2020 %>% \n  mutate(sexo_jefe=as_numeric(sexo_jefe)) %>% # para quitar el \"string\"\n  sjlabelled::set_labels(sexo_jefe, labels=etiqueta_sex) \n\n```\n\nEtiquetemos también la variable \"clase_hog\". Podemos checar cómo está estructurada esta base acá <https://www.inegi.org.mx/rnm/index.php/catalog/685/data-dictionary>\n\n```{r}\n\nconcentrado2020<-concentrado2020 %>% \n  mutate(clase_hog=as_numeric(clase_hog)) %>% # para quitar el \"string\"\n  sjlabelled::set_labels(clase_hog, labels=c(\"unipersonal\",\n                                             \"nuclear\", \n                                             \"ampliado\",\n                                             \"compuesto\",\n                                             \"corresidente\")) \n\n```\n\n```{r}\ntable(concentrado2020$sexo_jefe)\ntable(sjlabelled::as_label(concentrado2020$sexo_jefe))\n\n```\n\n### Ojeando\n\n```{r}\ndplyr::glimpse(concentrado2020)\ndplyr::glimpse(concentrado2020[,20:30]) # en corchete del lado derecho podemos ojear columnas \n\n```\n\nPodemos hacer un tipo \"labelbook\", usando una función que viene de la librería \"sjlabelled\", \"get_labels\". Funciona para toda la base o para columnas, o para variables.\n\n```{r}\n#print(get_labels(concentrado2020)) #todas\nprint(get_labels(concentrado2020[, 20:30])) #de las segundas 10 variables\n```\n\nNo tienen :(\n\nEn singular nos da las etiquetas de las variables, no de los valores:\n\n```{r}\n#print(get_label(concentrado2020)) #todas\nprint(get_label(concentrado2020[, 1:10])) #de las primeras 10 variables\nprint(get_label(concentrado2020$clase_hog)) #\n```\n\n### Selección de casos y de variables\n\nPoco a poco vamos comprendiendo más la lógica de R. Hay varias \"formas\" de programar. Por lo que no te asustes si varios códigos llegan al mismo resultado\n\nPara revisar el contenido de un data frame podemos usar, como lo hicimos anteriormente, el formato basededatos\\$var o usar corchete, checa como estas cuatro formas tan el mismo resultado.\n\n```{r}\nx<-concentrado2020$ing_cor\nx<-concentrado2020[[\"ing_cor\"]]  # ¡Ojo con las comillas! \nx<-concentrado2020[,23]\nx<-concentrado2020[,\"ing_cor\"]\n\n```\n\nAhora, con el formato de dplyr podemos llegar a lo mismo\n\n```{r}\nx<-concentrado2020 %>% \n  select(ing_cor)\n```\n\n## \"Subsetting\"\n\nSelección \"inversa\" O sea no \"botar algo\", es con el negativo. No funciona con todos los formatos\n\n```{r}\nx<-concentrado2020 %>% \n  select(-ing_cor)\n\nrm(x) #rm sólo bota objetos\n```\n\nPero con los otros formatos podemos \"asignar\" valores adentro de un data.frame, y uno de eso valores puede ser \"la nada\"\"\n\n```{r}\nconcentrado2020$aproba2<-concentrado2020$ing_cor\nconcentrado2020$aproba2<-NULL\n\n```\n\nDe aquí viene esa cuesta en el aprendizaje; tenemos que comprender en qué forma programó el que hizo la librería e incluso a veces cómo aprendió quién te está enseñando o el foro que estás leyendo.\n\nRara vez utilizamos una base de datos completa, y rara vez queremos hacer operaciones completas con ellas.\n\nVamos a pedir cosas más específicas y podemos seleccionar observaciones o filas. Como nuestra base de datos es muy grande, guardaremos el filtro o selección en un objeto.\n\n```{r}\nsubset1<-concentrado2020[concentrado2020$ing_cor>5000,]\n```\n\nTambién podemos seleccionar columnas\n\n```{r}\nsubset2<- concentrado2020[, c(\"sexo_jefe\", \"edad_jefe\", \"ing_cor\")]\n```\n\npodemos combinar los dos tipos de selección\n\n```{r}\nsubset3<- concentrado2020[(concentrado2020$ing_cor>5000 & concentrado2020$sexo_jefe==1 ), c(\"sexo_jefe\", \"edad_jefe\", \"ing_cor\")]\n```\n\nCon dplyr, podemos usar \"filter\" y \"select\"\n\n```{r}\n\nsubset4<-concentrado2020 %>% \n  dplyr::filter(ing_cor>5000 & sexo_jefe==1) %>%\n    dplyr::select(sexo_jefe, edad_jefe, ing_cor)\n```\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"P2.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.163","editor":"visual","theme":"spacelab"},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"P2.pdf"},"language":{},"metadata":{"block-headings":true,"editor":"visual","documentclass":"report"},"extensions":{"book":{}}}}}